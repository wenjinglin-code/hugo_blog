+++
title = "riscv 虚拟化"
date = 2025-11-12T00:00:00+08:00
tags = ["riscv", "virtual", "linux", "c3000"]
categories = ["riscv_linux"]
+++

# 硬件原理（priv-isa 13）

## 特权模式

**`HS-mode 和 S-mode 是一个东西，只是支持 hypervisor 改了名字，HS-mode 进入 VS-mode 通过 hstatus.spv = 1`**

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled.png)

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%201.png)

## CSR 访问

**`csr_hxxx 是 hs-mode 用来控制 vx-mode 的；csr_vsxx 是 vx-mode 访问 csr_sxxx 时，实际访问的寄存器`**

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%202.png)

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%203.png)

## 地址翻译

**`vstap 在 vx-mode 模式等价于 stap；hgatp 的 entry 是比 stap 的 entry 多两位的`**

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%204.png)

## 中断类型

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%205.png)

**`G-stage 翻译失败会触发  guest-page fault`**

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%206.png)

# kernel 内存结构

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%207.png)

# vcpu 运行流程

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%208.png)

# [qemu 启动虚拟机简易代码](https://www.cnblogs.com/LoyenWang/p/13796537.html)

```c
// tiny_qemu.c

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/kvm.h>
#include <sys/mman.h>

#define KVM_DEV     "/dev/kvm"
#define TINY_KERNEL_FILE    "./tiny_kernel.bin"
#define PAGE_SIZE  0x1000

int main(void)
{
    int kvm_fd;
    int vm_fd;
    int vcpu_fd;
    int tiny_kernel_fd;
    int ret;
    int mmap_size;
    
    struct kvm_sregs sregs;
    struct kvm_regs regs;
    struct kvm_userspace_memory_region mem;
    struct kvm_run *kvm_run;
    void *userspace_addr;

    /* open kvm device */
    kvm_fd = open(KVM_DEV, O_RDWR);
    assert(kvm_fd > 0);

    /* create VM */
    vm_fd = ioctl(kvm_fd, KVM_CREATE_VM, 0);
    assert(vm_fd >= 0);

    /* create VCPU */
    vcpu_fd = ioctl(vm_fd, KVM_CREATE_VCPU, 0);
    assert(vcpu_fd >= 0);

    /* open tiny_kernel binary file */
    tiny_kernel_fd = open(TINY_KERNEL_FILE, O_RDONLY);
    assert(tiny_kernel_fd > 0);
    /* map 4K into memory */
    userspace_addr = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    assert(userspace_addr > 0);
    /* read tiny_kernel binary into the memory */
    ret = read(tiny_kernel_fd, userspace_addr, PAGE_SIZE);
    assert(ret >= 0);

    /* set user memory region */
    mem.slot = 0;
    mem.flags = 0;
    mem.guest_phys_addr = 0;
    mem.memory_size = PAGE_SIZE;
    mem.userspace_addr = (unsigned long)userspace_addr;
    ret = ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &mem);
    assert(ret >= 0);

    /* get kvm_run */
    mmap_size = ioctl(kvm_fd, KVM_GET_VCPU_MMAP_SIZE, NULL);
    assert(mmap_size >= 0);
    kvm_run = (struct kvm_run *)mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu_fd, 0);
    assert(kvm_run >= 0);

    /* set cpu registers */
    ret = ioctl(vcpu_fd, KVM_GET_SREGS, &sregs);
    assert(ret >= 0);
    sregs.cs.base = 0;
    sregs.cs.selector = 0;
    ret = ioctl(vcpu_fd, KVM_SET_SREGS, &sregs);
    memset(&regs, 0, sizeof(struct kvm_regs));
    regs.rip = 0;
    ret = ioctl(vcpu_fd, KVM_SET_REGS, &regs);
    assert(ret >= 0);

    /* vcpu run */
    while (1) {
        ret = ioctl(vcpu_fd, KVM_RUN, NULL);
        assert(ret >= 0);

        switch(kvm_run->exit_reason) {
            case KVM_EXIT_HLT:
                printf("----KVM EXIT HLT----\n");
                close(kvm_fd);
                close(tiny_kernel_fd);
                return 0;
            case KVM_EXIT_IO:
                putchar(*(((char *)kvm_run) + kvm_run->io.data_offset));
                break;
            default:
                printf("Unknow exit reason: %d\n", kvm_run->exit_reason);
                break;
        }
    }

    return 0;
}
```

# vcpu 中断虚拟化（aplic 软件模拟，硬件使用 imsic g-file）（代码分支 riscv_kvm_aia_hwaccel_v1 ）

`参考文档：AIA_Virtualization_in_KVM_RISCV_final.pdf`

## 硬件原理（isa, riscv-interrupt）

### isa

- **写 g-file 的时候，in host，会触发 Supervisor guest external interrupt (SGEIP); in guest，就触发 Virtual supervisor external interrupt (VSEIP)**
- **配置 hideleg，可以将 Virtual supervisor external interrupt 直接由 vs 模式处理；在vs 中，Virtual supervisor external interrupt 会转换为 supervisor external interrupt，以便相同代码可以直接在 vs 执行；**
    
    ![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%209.png)
    
    ![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2010.png)
    
- hip.VSEIP = hvip.VSEIP | **hgeip.(hstatus.VGEIN)** | vs interrupt signal，hip.VSEIP 只能通过 **hvip.VSEIP** 清；
    
    ![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2011.png)
    
    hs 模式下，写 g-file 是触发 sge；
    
    vs 模式下， hideleg[10] ≠ 1 时，触发 vse 的时候，vs 会陷入 hs，hs 通过 hip 识别 vse 中断，hvip 清中断；
    
    **hideleg[10] = 1 时, vsip.SEIP/E ←→ hip.VSEIP/E, 因此 guest 可以直接控制 sip.SEIP 控制 vsip.SEIP 进而控制 hip.VSEIP**
    
    ![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2012.png)
    
- hip.SGEIP = **hgeip[hstatus.VGEIN]** & hgeie[hstatus.VGEIN] （hgeip 长度 = HSXLEN）
    
    ![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2013.png)
    

### IMSIC

hstatus.VGEIN （**0 s-file，1 - max guest index g-file**）决定了当前的 hart 选择了哪个 g-file 作为 imsic  的 interrupt file，vs 依旧可以使用原来的 siselect, sireg, and stopei 控制 imsic interrupt file

**`aplic 需要软件模拟（arch/riscv/kvm/aia_aplic.c），imsic 通过 g-file 实现虚拟化`**

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2014.png)

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2015.png)

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2016.png)

### 中断处理流程

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2017.png)

## linux 实现

### 框图

![Untitled](%E8%99%9A%E6%8B%9F%E5%8C%96/Untitled%2018.png)

### kvm aia 配置

```c
// 初始化 kvm aia
riscv_kvm_init
|- rc = kvm_riscv_aia_init();
|	 |- rc = aia_hgei_init(); // 注册guest ext 中断
|		  |- **kvm_riscv_aia_nr_hgei** = fls_long(csr_read(CSR_HGEIE)); // guest ext intrrupt max num
|		  |- hgei_parent_irq = irq_create_mapping(domain, IRQ_S_GEXT); // 申请中断号, **写 g-file 的时候，如果当下位于 host，会触发 Supervisor guest external interrupt; 位于 guest，就触发 Virtual supervisor external interrupt；**
|		  |- rc = request_percpu_irq(hgei_parent_irq, hgei_interrupt, "riscv-kvm", &aia_hgei); // 注册中断处理函数，其中只是唤醒 cpu
|		  |- rc = **kvm_register_device_ops**(&**kvm_riscv_aia_device_ops**, KVM_DEV_TYPE_RISCV_AIA); // **注册 aia 设备接口，应该是用户态用来配置aia 设备的（guest 支持的数量之类的）**
|		  | struct kvm_device_ops kvm_riscv_aia_device_ops = {
|		  | 	.name = "kvm-riscv-aia",
|		  | 	.create = aia_create,
|		  | 	.destroy = aia_destroy,
|		  | 	.set_attr = **aia_set_attr**,
|		  | 	.get_attr = aia_get_attr,
|		  | 	.has_attr = aia_has_attr,
|		  | };
|		  |- static_branch_enable(&kvm_riscv_aia_available);
|- rc = kvm_init(sizeof(struct kvm_vcpu), 0, THIS_MODULE);
	 |- r = cpuhp_setup_state_nocalls(CPUHP_AP_KVM_ONLINE, "kvm/cpu:online", **kvm_online_cpu**, kvm_offline_cpu);
	 |		// cpuhp 流程	 
	 |		kvm_online_cpu
	 |		|- ret = __hardware_enable_nolock();
	 |			 |- kvm_arch_hardware_enable()
	 |				  |- csr_write(CSR_HIDELEG, KVM_HIDELEG_DEFAULT); // **委派中断到 vs 模式, Virtual supervisor external interrupt 转换为 supervisor external interrupt**
	 |				  | #define KVM_HIDELEG_DEFAULT	 (BIT(IRQ_VS_SOFT)  | BIT(IRQ_VS_TIMER) | BIT(IRQ_VS_EXT))

// vcpu->arch.aia_context 初始化
kvm_vm_ioctl_create_vcpu
|- r = kvm_arch_vcpu_create(vcpu); // arch 相关的vcpu 配置(vcpu->arch)
	 |- cntx->hstatus |= HSTATUS_SPV; // 配置 V = 1, vcpu->arch.**guest_reset_context->hstatus** 
	 |- kvm_riscv_vcpu_timer_init(vcpu); // 配置 更新时钟的接口
	 |- rc = kvm_riscv_vcpu_aia_init(vcpu); // aia 初始化
		  |- vaia->imsic_addr = KVM_RISCV_AIA_UNDEF_ADDR; // -1
			|- **vaia->hart_index = vcpu->vcpu_idx**;
|- r = create_vcpu_fd(vcpu); // 创建 vcpu_fd

// 用户态配置 aia->aplic_addr vcpu_aia->imsic_addr(**GPA**)
aia_set_attr
|- r = aia_aplic_addr(dev->kvm, &addr, true); // aia->aplic_addr = *addr;
|- r = aia_imsic_addr(dev->kvm, &addr, type - KVM_DEV_RISCV_AIA_ADDR_IMSIC(0), true); // vcpu_aia->imsic_addr = *addr; 配置 **imsic_addr(GPA)** 
|- r = aia_init(dev->kvm);
	 |- ret = kvm_riscv_aia_aplic_init(kvm); // 初始化 aplic
	 |  |- kvm_iodevice_init(&aplic->iodev, &**aplic_iodoev_ops**);
	 |	|- ret = **kvm_io_bus_register_dev**(kvm, **KVM_MMIO_BUS**, kvm->arch.aia.aplic_addr, KVM_DEV_RISCV_APLIC_SIZE, &aplic->iodev); // 注册访问 aplic_addr的接口
	 |	|																																																												// **guest 通过**
	 |	|																																																												****// gstage_page_fault 
	 |	|																																																												// |-> kvm_riscv_vcpu_mmio_load / kvm_riscv_vcpu_mmio_store **访问 aplic**
	 |- ret = kvm_riscv_vcpu_aia_imsic_init(vcpu); // Initialize IMSIC for this VCPU
		  |- kvm_iodevice_init(&imsic->iodev, &**imsic_iodoev_ops**);
			|- ret = kvm_io_bus_register_dev(kvm, **KVM_MMIO_BUS**, vcpu->arch.aia_context.imsic_addr, KVM_DEV_RISCV_IMSIC_SIZE, &imsic->iodev);// 不清楚干嘛用到，**guest 通过 gstage_page_fault 访问 imsic (但是好像没用，下面会映射 imsic 的 gtp)**
```

### g-file 迁移

（~~还没弄 pcie msi 迁移~~，`pcie msi`依旧可以使用原来的 `msi addr`(guest file `gpa`) 触发，aia 上的外设就不行，因为其用的是 target 计算 `msi addr`）

```c
// guest file 迁移
kvm_arch_vcpu_ioctl_run
|- ret = kvm_riscv_vcpu_aia_update(vcpu);
	 |- return kvm_riscv_vcpu_aia_imsic_update(vcpu);
		  |- ret = **kvm_riscv_aia_alloc_hgei**(vcpu->cpu, vcpu, &new_vsfile_va, &new_vsfile_pa); // 获取新的 gfile, 返回 guest_idex
			|  |- /* TODO: To be updated later by AIA IMSIC HW guest file support */ // 还没实现，需要从 cpu 中找到没有用的 guest file，可能还需要更改 apaic 中的内容
			|  |- ret = __ffs(hgctrl->free_bitmap); // 获取空闲的 guest file
			|  |- lc = (gc) ? per_cpu_ptr(gc->local, cpu) : NULL; // 获取当前 cpu s-file 的地址
			|  |- *hgei_va = lc->msi_va + (ret * IMSIC_MMIO_PAGE_SZ); // 计算 cpu 对应 g-file 的地址
	    |- imsic_vsfile_local_clear(new_vsfile_hgei, imsic->nr_hw_eix); // 清除中断
	    |	 |- imsic_eix_write(IMSIC_EIP0 + i * 2, 0); //清除 penging
		  |	 |- imsic_eix_write(IMSIC_EIE0 + i * 2, 0); // 清楚 enable
		  |- ret = kvm_riscv_gstage_ioremap(kvm, vcpu->arch.aia_context.imsic_addr, new_vsfile_pa, IMSIC_MMIO_PAGE_SZ, true, true); 
		  |  | // **重新建立 imsic 映射, imsic_addr(GPA)->new_vsfile_pa(guest file HPA), 所以即使 guest 发生了迁移，guest 访问的还是 imsic_addr(GPA)，因此 guest 不感知** 
			|  | // 系统启动时，传递给 guest 的 imsic_addr 是用户态配的一个地址(gpa)，触发 page_fault 的时候，才将这个 gpa 映射到对应cpu 的 g-file (hpa)
		  |- imsic->vsfile_hgei = new_vsfile_hgei; // 更新 imsic 信息
		  |- imsic->vsfile_cpu = vcpu->cpu;
		  |- imsic->vsfile_va = new_vsfile_va;
		  |- imsic->vsfile_pa = new_vsfile_pa;
		  |- vcpu->arch.guest_context.hstatus |= ((unsigned long)new_vsfile_hgei) << HSTATUS_VGEIN_SHIFT; // hstatus.VGEIN 描述虚拟机编号，在这里更新
```

### 中断触发/处理流程

```c
// guest file interrupt 触发
// 模拟设备触发
kvm_vm_ioctl_irq_line
|- return kvm_riscv_aia_inject_irq(kvm, irql->irq, irql->level);
	 |- return kvm_riscv_aia_aplic_inject(kvm, irq, level);
		  |- irqd->state |= **APLIC_IRQ_STATE_PENDING**; // 根据触发类型判断是否注入
		  |- inject = true;
		  |- **aplic_inject_msi**(kvm, source, target);
			   |- kvm_riscv_aia_inject_msi_by_id(kvm, hart_idx, guest_idx, eiid);
				    |- return kvm_riscv_vcpu_aia_imsic_inject(vcpu, guest_index, 0, iid);
					     |- writel(iid, imsic->vsfile_va + IMSIC_MMIO_SETIPNUM_LE); // 写 g-file
					     |- kvm_vcpu_kick(vcpu); // 唤醒 vcpu
						      |- kvm_vcpu_wake_up(vcpu) // 唤醒 vcpu 所属于的线程，后续他继续进入 guest 中
																			      // 由于硬件进入 guest（sret） 的时候，会自动检测是否有中断，因此可以正常检测到注入的中断

// guest 主动触发
gstage_page_fault
|- return kvm_riscv_vcpu_mmio_store(vcpu, run, fault_addr, trap->htinst);
...
|- aplic_mmio_write
	 |- return aplic_mmio_write_offset(vcpu->kvm, addr - vcpu->kvm->arch.aia.aplic_addr, *((const u32 *)val));
		  |- aplic_write_pending(aplic, val32, true);
			|  |- irqd->state |= **APLIC_IRQ_STATE_PENDING**;
			|- aplic_update_irq_range(kvm, 1, aplic->nr_irqs - 1);
				 |- **aplic_inject_msi**(kvm, irq, target); // 有 pending 就执行
				 
// g-file 中断处理
// in host
hgei_interrupt // **Supervisor guest external interrupt; 位于 guest，就触发 Virtual supervisor external interrupt**
|- hgei_mask = csr_read(CSR_HGEIP) & csr_read(CSR_HGEIE); // 获取哪个 g-file 触发的中断
|- csr_clear(CSR_HGEIE, hgei_mask); // 清除中断使能，vcpu 进入休眠会重新打开（kvm_riscv_aia_wakeon_hgei）
|- kvm_vcpu_kick(hgctrl->owners[i]); // 唤醒 vcpu 去处理，vcpu 得到的中断号是普通的 external interrupt

// **in guest, 就触发 Virtual supervisor external interrupt, 在 guest 看到的是 普通的external interrupt**
```